# 单一职责原则
## 1. 什么是单一职责原则
一个类应该只有一个发生变化的原因。简单来说就是一个类仅负责其本书的职责，不应该糅合其他的职责进来。
例如：User 类仅负责用户相关的业务


## 2. 为什么要遵循单一职责原则
一个类如果不遵循单一职责原则，随着也谁发展和不断变化，就会出现难维护，不好拓展和测试难度大等问题。
换个角度讲，如果遵循了单一职责原则，能保证一个类的改动不会应该到其他类的工作，仅需要对当前类进行必要的单元测试。


## 3. 如何做到遵循单一职责原则
> 场景：
> 在一个视频网站中，有 3 类用户【访客，普通用户，VIP用户】，对应着不同的视频观看清晰度和是否有广告。
> 访客：最高观看 480P 清晰度的视频，有广告
> 普通用户：最高观看 720P 清晰度的视频，有广告
> VIP用户：最高观看 1080P 清晰度的视频，无广告

### 3.1 不遵循单一职责原则的代码
> 在一个类中，同时包含了 3 类用户的处理逻辑

```java
public class VideoUserService {  
    public void handle(String userType) throws Exception {  
        if ("GUEST".equals(userType)) {  
            // 业务处理  
            System.out.println("访客用户，可以观看 480P 清晰度的视频，有广告。");  
        } else if ("USER".equals(userType)) {  
            //业务处理  
            System.out.println("普通用户，可以观看 720P 清晰度的视频，有广告。");  
        } else if ("VIP".equals(userType)) {  
            //业务处理  
            System.out.println("普通用户，可以观看 720P 清晰度的视频，无广告。");  
        } else {  
            throw new Exception("Unsupported userType: " + userType);  
        }  
    }  
}
```


### 3.2 遵循单一职责原则的代码
> 先抽象出一个用户接口
```java
public interface IVideoUserService {  
    // 视频清晰度  
    String definition();  
    // 是否有广告  
    String advertise();  
}
```

> 为每类用户定义实现
```java
// VIP 用户
public class VipVideoUserService implements IVideoUserService{  
    @Override  
    public String definition() {  
        return "能观看 1080P 清晰度的视频";  
    }  
    @Override  
    public String advertise() {  
        return "无广告";  
    }  
}

// 普通用户
public class UserVideoUserService implements IVideoUserService{  
    @Override  
    public String definition() {  
        return "能观看 720P 清晰度的视频";  
    }  
    @Override  
    public String advertise() {  
        return "有广告";  
    }  
}

// 访客用户
public class GuestVideoUserService implements IVideoUserService{  
    @Override  
    public String definition() {  
        return "能观看 480P 清晰度的视频";  
    }  
    @Override  
    public String advertise() {  
        return "有广告";  
    }  
}
```

### 3.3 调用方使用
```java
public class SRPTest {  
    @Test  
    public void bad() throws Exception {  
        VideoUserService service = new VideoUserService();  
        service.handle("VIP");  
        service.handle("USER");  
        service.handle("GUEST");  
    }  
    @Test  
    public void good() {  
        IVideoUserService vipVideoUserService = new VipVideoUserService();  
        System.out.println("VIP用户。" + vipVideoUserService.definition() + vipVideoUserService.advertise());  
  
        IVideoUserService userVideoUserService = new UserVideoUserService();  
        System.out.println("普通用户。" + userVideoUserService.definition() + userVideoUserService.advertise());  
  
        IVideoUserService guestVideoUserService = new GuestVideoUserService();  
        System.out.println("游客用户。" + guestVideoUserService.definition() + guestVideoUserService.advertise());  
    }  
}
```


## 4. 解析
在第一个实现方式中，将 3 类用户的职责都糅合进一个类中，这使得每次其中一类用户的权限有变更时，`VideoUserService`  都需要被修改。例如，普通用户也不需要看广告了，那需要修改 `VideoUserService` 类，这也意味着，VIP用户和访客用户可能被影响到。

在第二种实现方式中，将 3 类用户的职责区分开，每一类用户有对应的一个类负责，针对其中一个类的修改不会影响到其他类的正常工作。
